[
["index.html", "极客R：数据分析之道 前言 内容简介 许可 建议与反馈 致谢", " 极客R：数据分析之道 王诗翔, 生信技能树 上次修改 2020-04-01 前言 这是一本 R 语言入门的教程书。它旨在为生物信息学相关方向的研究人员（包括学生）以及相关从业者提供 R 语言基础知识的学习指导。当然，由于本书内容的普适性，我相信对数据科学感兴趣的读者都能够从阅读中受益。如果读者已经掌握了一些 R 的编程知识，可以翻看目录挑选感兴趣的内容阅读；如果读者已经掌握的 R 编程基础知识，我推荐翻看本书的附录部分查找感兴趣的内容进一步深入学习。 R 语言与知名的 C、Python 这类通用编程语言相比，它是一门领域特定语言（domain-specific language、DSL），专注于数据科学领域。由于 Python 的普及以及它在商业、科研分析中的流行，R 语言常常被用来与 Python 作比较。我在此无意做这样的比较，就我的个人使用经验来看，两者都有其独特和独到之处。作为一名数据科学家，我们常常需要掌握多门编程语言作为工具进行工作，其中主要包括 R、Python 和 Shell。R 和 Python 都是作为主要的数据探索、分析和可视化工具，读者任选其一熟练掌握即可。初学者同时学习 R 和 Python 是不可取，因为不同的编程语言都有相似的数据结构和运算控制逻辑，所以深度掌握一门语言能够更好地工作和更快地学习其他编程语言。另外，初学者往往困惑于 R 和 Python 两种语言中哪种更值得学习。就我的个人观点看，对于生物信息学方向的大部分读者，R 是更好的选择，有以下一些理由： R 语言对于没有编程经验的读者更加友好，内置向量化运算机制和默认统计分析包可以快速开始分析和获取结果。 由于 Bioconductor 项目库和 CRAN 库中保存了上千个生物信息学软件包，涉及生物信息学领域的各个方面，读者在实际的研究工作中很难完全离开 R 语言环境。 tidyverse 系列工具包的强力驱动让 R 在数据分析各个方面工作都非常强力。 内容简介 当前已经有不少 R 语言和数据分析相关的教程和书籍，本书无力像它们一样详尽地介绍 R 众多方面的内容，而是聚焦于指导读者学习和理解数据分析的核心要点，并能快速应用到自己实际的工作中。本书的核心内容包括 R 的基础语法和一系列数据分析编程知识，后者将根据 Hadley 在《R for Data Science》提供的数据分析流程概览图 0.1 中指出的核心要点分别按章节进行介绍。最后，我们将通过一些 R 包学习 R 在生物信息学方向的应用。 图 0.1: 数据分析概览 （图源：R for Data Science 第 1 章） 本书的章节概要如下： 第 1 章介绍 R 与相应编程环境的安装和使用。 第 2 章介绍 R 基础编程语法，包括数据结构、控制流程等。 第 3 章介绍如何使用 R 导入常见的数据文件格式。 第 4 章介绍数据清洗操作在 R 中的实现。 第 5 章介绍数据可视化。 第 6 章介绍 R 在统计建模方面的和实践。 第 7 章介绍 R 怎样导出结果和生成分析报告。 第 8 章通过一些包的使用示例介绍 R 在生物信息学方向的应用。 许可 本网站（永久）免费阅读，以 CC 署名-非商业性使用-禁止演绎 4.0 国际协议发行。 建议与反馈 这是我第一次编写比较系统的 R 语言教程，由于个人能力有限，难免存在错误和不当，恳请读者批评指正。目前我在业余时间对本书内容进行积极的开发，如果读者有任何建议，欢迎到 GitHub 仓库 Issue 中进行讨论。 致谢 非常感谢谁谁以及谁谁对我的帮助。 王诗翔 于 上海 "],
["author.html", "作者简介", " 作者简介 王诗翔，生信技能树成员，R 语言爱好者。对编程、数据分析都有比较浓厚的兴趣，喜欢开源与开放的科学。长期在简书发文，连载文集《极客RrR&lt;&lt;-数据分析之道》，并运营微信公众号《优雅R》用于推送数据分析相关知识。 "],
["prepare.html", "第 1 章 准备工作 1.1 R 的下载和安装 1.2 RStudio 的下载和安装 1.3 配置（可选） 1.4 常见问题与方案", " 第 1 章 准备工作 想要在本地计算机上运行 R 语言代码，读者需要安装 R。为了方便 R 语言环境的使用和代码编写，我推荐读者使用 RStudio 公司开发的 R 集成开发环境（IDE）RStudio。 如果读者已经在计算机上安装好 R 和 RStudio，可以跳过本节内容。 如果读者倾向于使用像 VS Code 和 Idea 这样的流行编辑器，请自行安装对应的 R 语言拓展插件。 1.1 R 的下载和安装 点击链接 https://mirrors.tuna.tsinghua.edu.cn/CRAN/ 进入 CRAN 的清华镜像源，选择与自己操作系统对应的 R 进行下载。 Windows 系统用户进入 base 子目录，点击 Download R x.x.x for Windows。 MacOS 系统用户通过镜像地址进入 R for Mac OS X 页面后，点击 R-x.x.x.pkg 进行下载。 Linux 系统发行版众多，且需要一些额外的技术知识，请相应用户请阅读本章【常见问题与方案】一节学习 R 在 Linux 发行版下的安装。 上述的 x.x.x 指代 R 的版本号，目前是 3.6.3（2020-03），以用户下载时的实际版本号为准。 对于 MacOS 系统用户，下载后直接双击一路向下进行傻瓜式操作即可安装成功。 对于 Windows 系统用户，根据笔者几年的安装和使用经验，安装时有一些额外的注意事项： Windows 一般包含多个盘符，请读者尽量不要将 R 安装在 Program files 这样有空格的目录或中文目录下。读者可以自行创建一个专门的工具用于安装 R 以及放置 R 的三方包，如 C:/Tools，见图 1.1。 读者的电脑如果有 SSD 固态硬盘，最好将 R 安装到固态硬盘目录里，因为读写数据快。 一般现在电脑是 64 位的，如果你确定是这样，在安装时有关于 32 位的选项都可以不勾选，如图 1.2。 如果涉及到添加环境变量/路径之类的步骤，勾选添加即可。 以上没提到的，一路点下一步。 图 1.1: 设置安装路径 图 1.2: 只选择 64 位 在 Windows 或 MacOS 下读者如果想要安装含有像 C++ 这样的源码的包，需要安装编译工具如 g++，这些编译工具都被 R 语言团队打包成了 Rtools，如果读者有这方面的需求，请阅读本章【常见问题与方案】一节学习 Rtools 的安装。 1.2 RStudio 的下载和安装 点击链接 https://rstudio.com/products/rstudio/download/ 进入 RStudio 下载界面，根据自己的操作系统选择适合的安装文件进行安装即可，如图 1.3。 图 1.3: 下载 RStudio RStudio 的安装非常简单，没有特别的注意事项，读者可以直接一路点击向下。另外，读者可以自定义 RStudio 的安装路径，这不会影响 R 的使用。 RStudio 安装完成后可以像普通软件一样搜索和双击打开，如图 1.4。 图 1.4: RStudio 界面 下面对 RStudio 的界面进行简单介绍，读者在后续的使用中将会逐渐熟悉。 最上方是菜单栏，所有的功能都可以通过它们找到，没事可以多点一点。 左上方是代码编辑窗口，平时写代码的地方。 左下方是 R 控制台（还有终端和任务设定），我们可以通过控制台键入命令并观察 R 的输出（在代码编辑窗口中通过 Ctrl + Enter 快捷键可以将光标行代码发送到控制台，非常有用）。 整个右方是一些辅助窗口，最重要的是右上方的环境 Environment 窗口（用于展示当前环境中的对象：包括变量、函数等）和下方的 5 个窗口：Files、Plots、Packages、Help 以及 Viewer。 1.3 配置（可选） 下面的说明针对的是 Windows 系统，但对于其他系统也可以进行类似的设定。 Windows 下的 R 默认使用用户文档目录作为家目录（等同于 Linux 中的~），使用系统指定的临时目录作为临时目录，使用安装路径下的 R版本/library 目录作为 R 包存储目录。 如果读者什么都选择默认的， 当你一时安装包过多，或者装了电脑管家之类的管理软件时，系统的临时目录经常会把 RStudio 锁死，导致不能进行读写。 当你想要更新 R 版本时，有时你不得不面临重装所有包的举动（如果你使用几个月，装了几百个包…），或者想其他办法解决。 下面介绍如何创建自定义的临时目录与包目录，这样上面情况都不会发生了。 读者在安装好 R 和 RStudio 后，打开 RStudio，在 R 控制台键入： file.edit(&quot;~/.Rprofile&quot;) 在启动RStudio时，RStudio会首先执行里面的 R 代码，所以我们可以在这里用 R 代码进行配置。 首先在该文档内添加内容： #-------------------------------------------- # Set custom library and temp directory for R # NOTE: please only change following 2 paths # Any Question, please email to # Shixiang Wang &lt;w_shixiang@163.com&gt; #-------------------------------------------- .CUSTOM_LIB = &quot;C:/Tools/R/R_Library&quot; # set your custom library location .TMP = &quot;C:/Tools/R/Rtmp&quot; # set a temp dir for R running # please do not add &#39;/&#39; at the end !!! if(!dir.exists(.CUSTOM_LIB)){ dir.create(.CUSTOM_LIB, recursive = TRUE) } .libPaths(c(.CUSTOM_LIB, .libPaths())) message(&quot;Using library: &quot;, .libPaths()[1]) if(dirname(tempdir()) != .TMP){ if(!dir.exists(.TMP)) dir.create(.TMP, recursive = TRUE) cat(paste0(&quot;TMPDIR = &quot;, .TMP), file=&quot;~/.Renviron&quot;, sep = &quot;\\n&quot;) } message(&quot;Using temp directory: &quot;, .TMP) #--------------------------------------------------- # pacman is optional, you can delete following code # If you wanna use pacman, please read: # &lt;https://www.jianshu.com/p/cb16ded75672&gt; # Basically, # #1, you can use &#39;p_load&#39; to load multiple package into R # like p_load(data.table, dplyr) # #2, you can use &#39;p_get&#39; just to install package # #3, you can use &#39;p_update&#39; to update all packages #--------------------------------------------------- if(!require(pacman)){ install.packages(&quot;pacman&quot;, dependencies = TRUE) } library(pacman) #---------------------------------------------------- 然后根据情况对上述内容中的目录设定进行修改即可。 .CUSTOM_LIB = &quot;C:/Tools/R/R_Library&quot; # set your custom library location .TMP = &quot;C:/Tools/R/Rtmp&quot; # set a temp dir for R running # please do not add &#39;/&#39; at the end !!! pacman 那段代码是可选的，该包是 library() 函数的替代品，使用它安装和管理 R 包更简单。具体的使用方法可以点击阅读我之前的简书文章。 这里为了方便大家使用，我添加了一些必要注释，如果上述配置存在问题，读者可以发邮件给我。 保存后重启 RStudio 或者点击菜单栏 Session 下的 Restart R。 以后 RStudio 每次启动后都会输出读者计算机中 R 包的存储路径和它使用的临时路径。读者如果以后升级 R，只要重装下 R 安装文件就可以了，R 包的目录并不会改动，键入下面的命令可以更新所有的 R 包： p_update() 1.4 常见问题与方案 除了本节目前罗列的问题，读者在学习本章内容时遇到的其他问题都可以通过 GitHub Issue 提出和进行讨论。如果读者提出的是通性问题，将增补到该节。 1.4.1 R 在 Linux 系统下的安装 1.4.1.1 Ubuntu 从源安装 R 下述操作基于在 Ubuntu 18 系统上安装 R 3.5 的实践。 $ 前缀指明命令在 shell 终端中进行。 安装依赖： $ sudo apt-get install xorg-dev libreadline-dev $ sudo apt-get install libcurl4-openssl-dev $ sudo apt-get install libbz2-dev $ sudo apt-get install libcairo2-dev libgtk2.0-dev $ sudo apt-get install texinfo texlive $ wget http://mirrors.ctan.org/fonts/inconsolata.zip $ sudo cp -Rfp inconsolata/* /usr/share/texmf/ $ # 或者 sudo cp -r inconsolata/ /usr/share/texlive/texmf-dist/tex/latex/ $ sudo mktexlsr # 刷新 # 如果没有java解释器，安装下 $ sudo apt-get install default-jdk 下载与安装 R： $ curl -O http://cran.utstat.utoronto.ca/src/base/R-3/R-3.5.0.tar.gz $ tar -zxvf R-3.5.0.tar.gz $ cd R-3.5.0/ $ ./configure --prefix=$HOME/local/R --enable-R-shlib --with-cairo=yes $ # ./configure --with-cairo --with-libpng --with-libtiff --with-jpeglib --enable-R-shlib --prefix=$HOME/local/R $ make $ make install 创建符号链接： $ cd /usr/bin/ $ sudo ln -s $HOME/local/R/bin/Rscript Rscript $ sudo ln -s $HOME/local/R/bin/R R 检查： $ ls -l R* lrwxrwxrwx 1 root root 23 6月 28 17:01 R -&gt; /home/wsx/local/R/bin/R lrwxrwxrwx 1 root root 29 6月 28 17:01 Rscript -&gt; /home/wsx/local/R/bin/Rscript 使用： $ R R version 3.5.0 (2018-04-23) -- &quot;Joy in Playing&quot; Copyright (C) 2018 The R Foundation for Statistical Computing Platform: x86_64-pc-linux-gnu (64-bit) R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under certain conditions. Type &#39;license()&#39; or &#39;licence()&#39; for distribution details. Natural language support but running in an English locale R is a collaborative project with many contributors. Type &#39;contributors()&#39; for more information and &#39;citation()&#39; on how to cite R or R packages in publications. Type &#39;demo()&#39; for some demos, &#39;help()&#39; for on-line help, or &#39;help.start()&#39; for an HTML browser interface to help. Type &#39;q()&#39; to quit R. &gt; 如果遇到编译问题和报错，读者可以参考下面两篇博文： ubuntu 上安装 R 的时候遇到的问题总结 CentOS 下 R 的安装 1.4.1.2 CentOS 从源安装 R 下述操作基于在 CentOS 系统上安装 R 3.6 的实践。 $ 前缀指明命令在 shell 终端中进行。 首先切入 root 账户。 安装 R 编译依赖： $ yum-builddep R 消灭界面configure警告：configure: WARNING: neither inconsolata.sty nor zi4.sty found: PDF vignettes and package manuals will not be rendered optimally $ wget http://mirrors.ctan.org/fonts/inconsolata.zip $ Unzip inconsolata.zip $ cp -Rfp inconsolata/* /usr/share/texmf/ $ mktexlsr 下载 R 并解压： $ wget -c https://cran.r-project.org/src/base/R-3/R-3.6.0.tar.gz $ tar zxvf R-3.6.0.tar.gz 编译安装 $ cd R-3.6.0/ $ ./configure --prefix=/home/public/R/R-base --enable-R-shlib --with-cairo=yes 这里 prefix 后面的路径可以自己指定。 然后 $ make $ make install 最后可以把它链接到常用软件位置上去。 $ sudo ln -s /home/public/R/R-basebin/R /bin/R 1.4.2 Rtools 安装 1.4.2.1 Windows 系统 Rtools 点击链接 https://mirrors.tuna.tsinghua.edu.cn/CRAN/ 进入 CRAN 页面，依次点击【Download R for Windows】、【Rtools】，然后选择推荐的版本下载和安装，如图 1.5。 图 1.5: Windows 下 Rtools 的下载 安装时一路点击向下，建议不要修改安装路径，因为 R 的很多编译环境变量设定都指向默认的安装路径，读者如果修改它后续很可能引起不必要的麻烦。 1.4.2.2 MacOS 系统 Rtools 点击链接 https://mirrors.tuna.tsinghua.edu.cn/CRAN/ 进入 CRAN 页面，依次点击【Download R for Mac OS X】、【tools】，然后选择最新版的 clang-x.x.x.pkg 和 gfortran-x.x.x.pkg 下载和安装即可，如图 1.6。 x.x.x 指代版本号，如 8.0.0。 图 1.6: MacOS 下 Rtools 的下载 1.4.3 RStudio Server 安装 RStudio Server 比较好用，适用于安装在小型服务器上以方便多人同时利用服务器的计算资源。需要注意，RStudio Server 的安装需要管理员（root）权限。 点击链接 https://rstudio.com/products/rstudio/download-server/ 进入 RStudio Server 下载页面，针对不同的 Linux 发行版，RStudio 公司已经有良好的文档支持，所以我不再赘述。 在使用 RStudio Server 时我有一个小小的建议，如我在前面的配置一节所说，读者可以自己创建一个专门的目录管理所有的 R 包。并且针对该目录，建议新建一个 Linux 群组以管理它的访问权限。 这里简介一下安装后添加其他人，以增加用户 rotation 为例： $ sudo useradd rotation -d /home/rotation -m -g wsx # 将新增用户添加到你所在群组 $ sudo passwd rotation # 设定初始密码 $ sudo adduser rotation sudo # 给用户添加sudo权限，以方便一些操作 "],
["base.html", "第 2 章 基础语法 2.1 基本数据结构 2.2 控制结构 2.3 函数与函数式编程 2.4 包的安装与使用 2.5 实战：ROC 曲线计算与绘制 2.6 常见问题与方案", " 第 2 章 基础语法 “程序 = 算法 + 数据结构”，数据结构是信息的载体，而算法是完成任务所需要的步骤。两者的构造和使用方法形成了编程语言独特的语法。本章先介绍 R 的基本数据结构，然后介绍条件和循环控制，最后介绍函数的创建与拓展包的使用。 2.1 基本数据结构 为了表示现实世界的信息，各类编程语言常包含 3 种基本的数据类型：数值型，包括整数和浮点数；字符型，表示文本信息；逻辑型，也常称为布尔值，表示是非判断，如对与错，是与否。在 R 中，除了这些基本数据类型的实现，为了方便计算工作，R 本身还包含了矩阵、数据框和列表等复杂的数据类型，以支持表示各类常用的数据。 2.1.1 向量 在 R 中，数据运算常通过向量的形式进行。向量是一组同质的信息，如 20 个数字、30 个字符串（与数学术语中的向量类似，但不等同）。单一的信息在此被称为元素。标量可以看作元素数量为 1 的向量。 接下来我们通过向量元素的数据类型来实际地了解和操作它。 2.1.1.1 数值 数值应该可以说是最常用的信息表现形式，如人的身高、年龄。在 R 中使用小学学到的阿拉伯表示法即可创建数值，如圆周率 \\(\\pi\\)： 3.14 #&gt; [1] 3.14 此处 #&gt; 后显示 R 运行代码后的返回结果，[1] 是结果的索引，以辅助用户观测，这里表示结果的第 1 个值是 3.14。 typeof() 与 class() 是两个对于初学者非常有用的函数，它们可以返回数据的类型信息。 typeof(3.14) #&gt; [1] &quot;double&quot; class(3.14) #&gt; [1] &quot;numeric&quot; 在 R 中不需要像其他语言一样区分数值的精度信息，typeof() 返回结果为 double 提示该值是一个浮点数。 在 R 中，任何所见的事物皆为对象，class() 返回对象的类信息，此处是 numeric（数值）。 我们再来看看如何在 R 中表示整数。借助上述两个工具函数，我们不难发现下面的代码与想象不同。 3 #&gt; [1] 3 typeof(3) #&gt; [1] &quot;double&quot; class(3) #&gt; [1] &quot;numeric&quot; typeof() 与 class() 对于 3 的返回结果与 3.14 完全相同！这是因为即便只输入 3，R 也将其作为浮点数对待。 我们可以利用 identical() 函数或 is.integer() 函数进行检查： identical(3, 3.0) #&gt; [1] TRUE is.integer(3) #&gt; [1] FALSE 返回的结果是后面将介绍的逻辑值，TRUE 表示对、FALSE 表示错。因此可以判断 3 并不是整数。 正确的整数表示方法需要在数字后加 L 后缀，如 3L。 is.integer(3L) #&gt; [1] TRUE identical(3L, 3) #&gt; [1] FALSE is.integer() 函数隶属于 is.xxx() 家族，该函数家族用于辅助判断对象是否属于某一类型。读者在 RStudio 中输入 is. 后 RStudio 将智能提示有哪些函数的名字以 is. 开头。 浮点数和整数都是数值，所以下面的代码都会返回 TRUE： is.numeric(3.14) #&gt; [1] TRUE is.numeric(3L) #&gt; [1] TRUE 现实中的数据常成组出现，例如，一组学生的身高。R 使用 c() 函数（c 为 combine 的缩写）对数据进行组合： c(1.70, 1.72, 1.80, 1.66, 1.65, 1.88) #&gt; [1] 1.70 1.72 1.80 1.66 1.65 1.88 这样我们就有了一组身高数据。 利用 R 自带的 mean() 和 sd() 还是我们可以轻易求取这组数据的均值和标准差： # 均值 mean(c(1.70, 1.72, 1.80, 1.66, 1.65, 1.88)) #&gt; [1] 1.735 # 标准差 sd(c(1.70, 1.72, 1.80, 1.66, 1.65, 1.88)) #&gt; [1] 0.08894 上面我们计算时我们重复输入了身高数据，如果在输入时发生了小小的意外，如计算标准差时将 1.65 写成了 1.66，那么我们分析得就不是同一组数据了！虽然说在上述的简单计算不太可能发生这种情况，但如果存在 100 甚至 1000 个数据的重复输入，依靠人眼判断几乎是必然出错的。 一个解决办法是依赖系统自带的复制粘贴机制，但如果一组数据被上百次重复使用，这种办法也不实际。 正确的解决办法是引入一个符号（Symbol），用该符号指代一组数据，然后每次需要使用该数据时，使用符号代替即可。符号在编程语言中也常被称为变量，后面我们统一使用该术语。 上述代码块改写为： heights &lt;- c(1.70, 1.72, 1.80, 1.66, 1.65, 1.88) mean(heights) #&gt; [1] 1.735 sd(heights) #&gt; [1] 0.08894 &lt;- 符号在 R 中称为赋值符号，我们可以将它看作数据的流动方向，这样更方便理解，我们不难猜测到 -&gt; 的写法也是有效的： c(1.70, 1.72, 1.80, 1.66, 1.65, 1.88) -&gt; heights2 heights2 #&gt; [1] 1.70 1.72 1.80 1.66 1.65 1.88 但通常以 &lt;- 的写法为主。 另外，= 符号与 &lt;- 有基本相同的含义，但不常用。如果读者有其他编程语言经验，也可以使用它作为常用赋值符号。两者的区别见本章【常见问题与方案】一节。 R 中变量的命名有一些限制，最重要的就是不要以数字开头： 3ab = 3 #&gt; Error: &lt;text&gt;:1:2: unexpected symbol #&gt; 1: 3ab #&gt; ^ 变量命名有 2 点建议： 对于一些临时使用的变量，以简单为主，如 i、j、k 等。 与数据相关的命名，建议与其信息一致，如上面的代码我使用了 heights，不然在没有注释的情况下，代码的阅读者无法快速理解你写的程序。 另外，长变量的命名通常有 2 个推荐的规则： 骆驼法 以学生身高数据为例，可以写为 studentHeights，它遵循 aBcDeF 这样的构造方式。 蛇形 以下划线作为分隔符，写为 student_heights。 两种写法在 R 中都很常用，读者选择一种即可，重点在于一个 R 脚本中应当保持变量名命名风格的一致。 在了解向量和变量后，我们再来学习下向量的计算方式。 假设我们有两组数据，分别以变量 a 和 b 存储： a &lt;- c(1, 2, 3) b &lt;- c(4, 5, 6) 我们将其堆叠到一起，如图 2.1： 图 2.1: 向量的直观展示 当我们将 a 与 b 相加，结果是什么呢？ a + b #&gt; [1] 5 7 9 两个向量之和是向量元素一一相加组成的向量。如果向量的元素不相同，结果又是如何呢？ 我们将 a 与 4 相加看一看，此时向量堆叠如图 2.2 所示： 图 2.2: 向量不等长图示 a + 4 #&gt; [1] 5 6 7 上述结果与 a + c(4, 4, 4) 相同： a + c(4, 4, 4) #&gt; [1] 5 6 7 因此，如果向量不等长时，短向量会通过重复与长向量先对齐（如图 2.3），然后再相加。 图 2.3: 向量对齐 注意，此过程中，长向量会保持不变，如果出现短向量重复后无法对齐的情况，多余的部分将被扔掉，R 返回结果的同时会抛出一个警告信息。 c(1, 2, 3) + c(4, 5) #&gt; Warning in c(1, 2, 3) + c(4, 5): longer object length #&gt; is not a multiple of shorter object length #&gt; [1] 5 7 7 # 上面的加法等价于 c(1, 2, 3) + c(4, 5, 4) 整个过程称为向量化运算。除了加法，其他任何向量（几何）运算方式都相同。 # 想减 a - b #&gt; [1] -3 -3 -3 # 相除 a / b #&gt; [1] 0.25 0.40 0.50 # 相乘 a * b #&gt; [1] 4 10 18 # 整除 a %/% b #&gt; [1] 0 0 0 # 取余数 a %% b #&gt; [1] 1 2 3 # 平方 a ^ 2 #&gt; [1] 1 4 9 # 取对数 log(a, base = 2) #&gt; [1] 0.000 1.000 1.585 向量化运算的本质是成对的向量元素运算操作。这个特性让 R 在处理数据时非常方便，无论向量元素的个数是多少，在运算时我们都可以将其作为标量对待。 例如，计算数据 heights 的均值和标准差，这里我们直接通过公式而不是 R 自带的函数进行计算： \\[ \\mu = \\frac{\\sum x_i}{n} \\] \\[ sd = \\sqrt\\frac{\\sum(x_i - \\mu)^2}{n - 1} \\] sd 的计算中使用的是 n-1 而不是 n 的原因是我们计算的是样本标准差。 实际操作如下： # 先计算均值 heightsMean &lt;- sum(heights) / length(heights) heightsMean #&gt; [1] 1.735 # 计算标准差 heightsSD &lt;- sqrt( sum( (heights - heightsMean)^ 2) / (length(heights) - 1) ) heightsSD #&gt; [1] 0.08894 将结果与 R 函数计算结果对比： mean(heights) #&gt; [1] 1.735 sd(heights) #&gt; [1] 0.08894 注意，上述我们使用了 R 的一些其他工具函数，length() 用来获取向量的长度，而 sum() 用来获取向量之和，sqrt() 用来计算开方。 初学者可能对于计算中使用的一些计算函数感到陌生，这是非常非常非常正常的，我个人也无法记得所有 R 提供的函数，编程是一门实践课程，读者需要通过使用去熟悉，而无法通过死记硬背掌握。在想要使用自己不知道的函数时，这里有几点建议： 猜测函数名。R 的函数命名方式是有规律可循的，且大体有对应的英文含义，读者不妨先尝试猜一猜函数名，看看是否真的有。 使用 R 的文档系统。R 的文档系统非常丰富，读者可以在 R 控制台 ?numeric 来获取关于 numeric 的相关信息。而 ??numeric 可以进行更为深度的搜索。学会读和理解函数文档是掌握 R 必备的技能。 使用搜索引擎。（初学者）遇到的问题基本都会有人遇到，R 的用户众多，各个博客和论坛都记录了关于 R 的使用和问题讨论，在上述 2 点无法解决问题时，读者不妨多使用搜索引擎查找相关资料。 这一小节我们通过数值数据作为对象学习了一些重要的 R 基础概念和操作。接下来我们将这些知识拓展到其他基础数据类型中就相对容易多了。 2.1.1.2 字符串 日常数据处理任务中除了常见的数值型数据，文本数据也比较常用。例如，表示性别是“男”或“女”，教育程度是“中学”还是“大学”。 在 R 中，并不能直接通过输入非数值的字符创建字符串： 男 #&gt; Error in eval(expr, envir, enclos): object &#39;男&#39; not found 文本数据需要通过单引号 '' 或双引号 \"\" 引号括起来，这样就可以创建字符串了： &#39;男&#39; #&gt; [1] &quot;男&quot; &quot;女&quot; #&gt; [1] &quot;女&quot; typeof(&quot;abcde&quot;) #&gt; [1] &quot;character&quot; class(&quot;abcde&quot;) #&gt; [1] &quot;character&quot; 函数 nchar() 常用于获取字符串中字符的个数： nchar(&quot;abcde&quot;) #&gt; [1] 5 注意，这与获取字符串向量的元素个数是不同的： abc &lt;- c(&quot;abcde&quot;, &quot;f&quot;, &quot;g&quot;) length(abc) #&gt; [1] 3 nchar(abc) #&gt; [1] 5 1 1 字符串常涉及集合操作，如交集、并集、差集: # 交集 intersect(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;)) #&gt; [1] &quot;a&quot; &quot;b&quot; # 并集 union(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;)) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; # 差集 setdiff(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;)) #&gt; [1] &quot;c&quot; 注意，集合操作同样适用于其他数据类型，读者不妨试一试。 2.1.1.3 因子 因子是另类的字符串，它引入了水平信息，更有利于保存和展示分类的文本数据，创建方式如下： sex &lt;- factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;)) sex #&gt; [1] Male Female Female Male Male #&gt; Levels: Female Male 上述结果除了打印向量本身的元素，还输出了变量 sex 的水平信息。水平信息可以通过 levels() 函数获取。 levels(sex) #&gt; [1] &quot;Female&quot; &quot;Male&quot; 重命名因子水平，可以完成对应所有元素的修改： levels(sex) &lt;- c(&quot;Female&quot;, &quot;男的&quot;) sex #&gt; [1] 男的 Female Female 男的 男的 #&gt; Levels: Female 男的 水平可以在创建因子时指定，如果一些分类没有对应的水平，将被转换为 NA（Not Available 的缩写），NA 是 R 中比较特殊的一个值，表示数据未知的状态。 factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;M&quot;, &quot;M&quot;), levels = c(&quot;Male&quot;, &quot;Female&quot;)) #&gt; [1] Male Female Female Male Male &lt;NA&gt; &lt;NA&gt; #&gt; Levels: Male Female 除了水平，我们还可以为分类添加标签以展示某一分类对应的具体信息： factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;M&quot;, &quot;M&quot;), levels = c(&quot;Male&quot;, &quot;Female&quot;), labels = c(&quot;性别：男&quot;, &quot;性别：女&quot;)) #&gt; [1] 性别：男 性别：女 性别：女 性别：男 性别：男 #&gt; [6] &lt;NA&gt; &lt;NA&gt; #&gt; Levels: 性别：男 性别：女 初学者需要额外注意，R 代码不支持中文，中文以及特殊字符只能出现在字符串中，两者的换用是代码出错的常见原因。 2.1.1.4 逻辑值 逻辑值仅有 2 个：TRUE 和 FALSE，对应缩写为 T 和 F。一般并不会直接使用逻辑值存储信息，而是使用它管理程序的逻辑，这一点在本章【控制结构与循环】一节中介绍。 逻辑值的另外一个重要作用是对数据取子集，相比于整数索引，它更加的高效。 我们先看一下如何利用整数索引提取子集，如提取变量 heights 的第 2 个元素： heights[2] #&gt; [1] 1.72 再提取第 2 到第 5 个元素，这会形成新的向量： heights[2:5] #&gt; [1] 1.72 1.80 1.66 1.65 这里 2:5 是一个便捷操作，它生成了整数向量 c(2, 3, 4, 5)： 2:5 #&gt; [1] 2 3 4 5 如果使用负号，将会去掉对应的元素： heights #&gt; [1] 1.70 1.72 1.80 1.66 1.65 1.88 heights[-2] #&gt; [1] 1.70 1.80 1.66 1.65 1.88 在实际工作中，需要提取的数据子集通常不会这么有序，因此需要借助比较运算符和 which() 函数获取子集数据的索引。 例如，找出身高大于 1.7 的数据： # 先使用 which() 找出索引 which(heights &gt; 1.7) #&gt; [1] 2 3 6 # 然后组合取子集操作提取子集数据 heights[which(heights &gt; 1.7)] #&gt; [1] 1.72 1.80 1.88 实际上，我们完全没有必要引入 which() 函数用来返回数据的整数索引，heights &gt; 1.7 比较的结果是一个逻辑值向量，它本身就可以作为索引用于提取子集。 heights &gt; 1.7 #&gt; [1] FALSE TRUE TRUE FALSE FALSE TRUE heights[heights &gt; 1.7] #&gt; [1] 1.72 1.80 1.88 TRUE 对应的元素被保留，而 FALSE 对应的元素被去除。请读者记住，逻辑索引是首选的取子集方式，它更加高效。 2.1.1.5 深入向量 向量除了保存数据，还可以保存与之相关的属性。例如，为了更好展示 heights 信息，我们可以增加名字属性。 names(heights) &lt;- paste(&quot;Student:&quot;, 1:6) heights #&gt; Student: 1 Student: 2 Student: 3 Student: 4 Student: 5 #&gt; 1.70 1.72 1.80 1.66 1.65 #&gt; Student: 6 #&gt; 1.88 上述代码中，paste() 将两个向量粘贴到一起，默认中间存在空格。 paste(&quot;Student:&quot;, 1:6) #&gt; [1] &quot;Student: 1&quot; &quot;Student: 2&quot; &quot;Student: 3&quot; &quot;Student: 4&quot; #&gt; [5] &quot;Student: 5&quot; &quot;Student: 6&quot; # 修改分隔符 paste(&quot;Student&quot;, 1:6, sep = &quot;-&quot;) #&gt; [1] &quot;Student-1&quot; &quot;Student-2&quot; &quot;Student-3&quot; &quot;Student-4&quot; #&gt; [5] &quot;Student-5&quot; &quot;Student-6&quot; names() 函数不仅可以设定名字属性，还可以查看： names(heights) #&gt; [1] &quot;Student: 1&quot; &quot;Student: 2&quot; &quot;Student: 3&quot; &quot;Student: 4&quot; #&gt; [5] &quot;Student: 5&quot; &quot;Student: 6&quot; R 中很多函数都与 names() 类似，不仅可以用于修改，同时还可以用于获取对应的信息。 另外，R 对象所具有的属性可以通过 attributes() 函数查看： attributes(heights) #&gt; $names #&gt; [1] &quot;Student: 1&quot; &quot;Student: 2&quot; &quot;Student: 3&quot; &quot;Student: 4&quot; #&gt; [5] &quot;Student: 5&quot; &quot;Student: 6&quot; R 默认的类系统非常自由，我们可以任意设定属性，如增加一个班级属性： attr(heights, &quot;class-name&quot;) &lt;- &quot;A&quot; attr(heights, &quot;class-name&quot;) #&gt; [1] &quot;A&quot; attributes(heights) #&gt; $names #&gt; [1] &quot;Student: 1&quot; &quot;Student: 2&quot; &quot;Student: 3&quot; &quot;Student: 4&quot; #&gt; [5] &quot;Student: 5&quot; &quot;Student: 6&quot; #&gt; #&gt; $`class-name` #&gt; [1] &quot;A&quot; 在创建向量时，一些函数会相当有用，如 rep()，它可以用来重复数据。 rep(1:4, 3) #&gt; [1] 1 2 3 4 1 2 3 4 1 2 3 4 rep(1:4, each = 3) #&gt; [1] 1 1 1 2 2 2 3 3 3 4 4 4 读者如果想要更新部分向量值，直接对提取的子集重新赋值即可。 heights2 #&gt; [1] 1.70 1.72 1.80 1.66 1.65 1.88 heights2[heights2 &gt; 1.8] &lt;- 1.8 heights2 #&gt; [1] 1.70 1.72 1.80 1.66 1.65 1.80 2.1.2 数组与矩阵 我们前面看的的向量都是一个维度的，如果我们增加维度信息，将形成数组。2 维的数组比较常用，被称为矩阵。 创建一个 2x2x3 的数组： array(1:12, dim = c(2, 2, 3)) #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 5 7 #&gt; [2,] 6 8 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] #&gt; [1,] 9 11 #&gt; [2,] 10 12 创建一个 4x3 的矩阵： matrix(1:12, nrow = 4, ncol = 3, byrow = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 矩阵包含 2 个常用的属性，行名 rownames 和列名 colnames： M &lt;- matrix(1:12, nrow = 4, ncol = 3, byrow = TRUE) rownames(M) #&gt; NULL colnames(M) #&gt; NULL 上述创建矩阵时我们没有设定，所以默认是 NULL（空值）。我们可以自行设定： rownames(M) &lt;- paste0(&quot;a&quot;, 1:4) colnames(M) &lt;- paste0(&quot;b&quot;, 1:3) M #&gt; b1 b2 b3 #&gt; a1 1 2 3 #&gt; a2 4 5 6 #&gt; a3 7 8 9 #&gt; a4 10 11 12 还可以获取矩阵的维度信息： dim(M) #&gt; [1] 4 3 # 行数 nrow(M) #&gt; [1] 4 # 列数 ncol(M) #&gt; [1] 3 针对数值矩阵，一些运算非常有用： # 矩阵和 sum(M) #&gt; [1] 78 # 矩阵均值 mean(M) #&gt; [1] 6.5 # 行和 rowSums(M) #&gt; a1 a2 a3 a4 #&gt; 6 15 24 33 # 列和 colSums(M) #&gt; b1 b2 b3 #&gt; 22 26 30 # 行均值 rowMeans(M) #&gt; a1 a2 a3 a4 #&gt; 2 5 8 11 # 列均值 colMeans(M) #&gt; b1 b2 b3 #&gt; 5.5 6.5 7.5 取子集操作依旧是适用的，逗号 , 用于分割不同的维度： # 第 1 行第 1 列的元素 M[1, 1] #&gt; [1] 1 # 第 1 行 M[1, ] #&gt; b1 b2 b3 #&gt; 1 2 3 # 第 1 列 M[, 1] #&gt; a1 a2 a3 a4 #&gt; 1 4 7 10 # 前 2 行 M[1:2, ] #&gt; b1 b2 b3 #&gt; a1 1 2 3 #&gt; a2 4 5 6 # 前 2 列 M[, 1:2] #&gt; b1 b2 #&gt; a1 1 2 #&gt; a2 4 5 #&gt; a3 7 8 #&gt; a4 10 11 当取单行时，由于维度信息默认丢失，返回的是一维向量，我们可以显式指定保留矩阵形式，如： M[, 1, drop = FALSE] #&gt; b1 #&gt; a1 1 #&gt; a2 4 #&gt; a3 7 #&gt; a4 10 逻辑索引也可以使用： M[rowMeans(M) &gt; 5, ] #&gt; b1 b2 b3 #&gt; a3 7 8 9 #&gt; a4 10 11 12 2.1.3 数据框 数据框（data.frame）是 R 中非常独特的一种数据结构，它可以非常好存储和展示常见的表格数据。从外形上看，它与矩阵非常相似，但与矩阵不同的是，数据框的列可以是不同的数据类型。 例如，创建一个数据框存储性别，年龄和身高数据。 df &lt;- data.frame( sex = c(&quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;), age = c(17, 29, 20, 33), heights = c(1.66, 1.84, 1.83, 1.56) ) df #&gt; sex age heights #&gt; 1 F 17 1.66 #&gt; 2 M 29 1.84 #&gt; 3 M 20 1.83 #&gt; 4 F 33 1.56 str() 非常方便用于观察复杂数据类型的结构： str(df) #&gt; &#39;data.frame&#39;: 4 obs. of 3 variables: #&gt; $ sex : Factor w/ 2 levels &quot;F&quot;,&quot;M&quot;: 1 2 2 1 #&gt; $ age : num 17 29 20 33 #&gt; $ heights: num 1.66 1.84 1.83 1.56 默认，数据框中字符列会被自动转换为因子类型，我们可以通过设定修改它。 df &lt;- data.frame( sex = c(&quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;), age = c(17, 29, 20, 33), heights = c(1.66, 1.84, 1.83, 1.56), stringsAsFactors = FALSE ) df #&gt; sex age heights #&gt; 1 F 17 1.66 #&gt; 2 M 29 1.84 #&gt; 3 M 20 1.83 #&gt; 4 F 33 1.56 str(df) #&gt; &#39;data.frame&#39;: 4 obs. of 3 variables: #&gt; $ sex : chr &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; #&gt; $ age : num 17 29 20 33 #&gt; $ heights: num 1.66 1.84 1.83 1.56 很多适用于矩阵的操作同样适用于数据框。 例如，获取维度信息： dim(df) #&gt; [1] 4 3 # 行数 nrow(df) #&gt; [1] 4 # 列数 ncol(df) #&gt; [1] 3 例如，获取和设定行、列名： rownames(df) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; colnames(df) #&gt; [1] &quot;sex&quot; &quot;age&quot; &quot;heights&quot; rownames(df) &lt;- paste0(&quot;Stu&quot;, 1:4) # 将列名大写 colnames(df) &lt;- toupper(colnames(df)) df #&gt; SEX AGE HEIGHTS #&gt; Stu1 F 17 1.66 #&gt; Stu2 M 29 1.84 #&gt; Stu3 M 20 1.83 #&gt; Stu4 F 33 1.56 数据框支持多种取子集的操作，包括整数索引、逻辑索引、行列名。 先看整数索引： df[1:2, 1:2] #&gt; SEX AGE #&gt; Stu1 F 17 #&gt; Stu2 M 29 再看逻辑索引： df[c(TRUE, TRUE, FALSE, FALSE), c(TRUE, TRUE, FALSE)] #&gt; SEX AGE #&gt; Stu1 F 17 #&gt; Stu2 M 29 # 等价于 df[rownames(df) %in% c(&quot;Stu1&quot;, &quot;Stu2&quot;), colnames(df) %in% c(&quot;SEX&quot;, &quot;AGE&quot;)] #&gt; SEX AGE #&gt; Stu1 F 17 #&gt; Stu2 M 29 这里 %in% 运算符是成员判断操作，如 'a' %in% c('a', 'b') 是判断 'a' 是否在字符串向量 c('a', 'b') 中。第二种写法看起来比较繁琐，但实际工作中比较常用。 我们还可以直接使用名字： df[c(&quot;Stu1&quot;, &quot;Stu2&quot;), c(&quot;SEX&quot;, &quot;AGE&quot;)] #&gt; SEX AGE #&gt; Stu1 F 17 #&gt; Stu2 M 29 单独提取某一列生成一个向量是一个常用操作，读者可以使用两种操作符，包括 [[]] 和 $。 例如提取 SEX 列： df[[1]] #&gt; [1] &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; df[[&quot;SEX&quot;]] #&gt; [1] &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; df$SEX #&gt; [1] &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; 需要注意 [[]] 与 [] 的区别，后者依旧返回一个数据框： df[&#39;SEX&#39;] #&gt; SEX #&gt; Stu1 F #&gt; Stu2 M #&gt; Stu3 M #&gt; Stu4 F 另外，取子集操作可以使用 R 提供的 subset() 函数： # 取行 subset(df, subset = rownames(df) %in% c(&quot;Stu1&quot;, &quot;Stu2&quot;)) #&gt; SEX AGE HEIGHTS #&gt; Stu1 F 17 1.66 #&gt; Stu2 M 29 1.84 # 取列 subset(df, select = colnames(df) == &quot;SEX&quot;) #&gt; SEX #&gt; Stu1 F #&gt; Stu2 M #&gt; Stu3 M #&gt; Stu4 F # 同时筛选行和列 subset(df, subset = rownames(df) %in% c(&quot;Stu1&quot;, &quot;Stu2&quot;), select = colnames(df) == &quot;SEX&quot;) #&gt; SEX #&gt; Stu1 F #&gt; Stu2 M 数据框如果想要修改或更新某列，像向量一样重新赋值即可： df$AGE &lt;- 20 df #&gt; SEX AGE HEIGHTS #&gt; Stu1 F 20 1.66 #&gt; Stu2 M 20 1.84 #&gt; Stu3 M 20 1.83 #&gt; Stu4 F 20 1.56 2.1.4 列表 列表可以表示非常非常非常复杂的数据结构。数据框可以看作列表所有列元素长度相同的特例。 创建一个列表如下： l &lt;- list( sex = c(&quot;F&quot;, &quot;M&quot;), age = c(17, 29, 20), heights = c(1.66, 1.84, 1.83, 1.56) ) l #&gt; $sex #&gt; [1] &quot;F&quot; &quot;M&quot; #&gt; #&gt; $age #&gt; [1] 17 29 20 #&gt; #&gt; $heights #&gt; [1] 1.66 1.84 1.83 1.56 从输出上我们就可以知道如何提取不同的信息： l$sex #&gt; [1] &quot;F&quot; &quot;M&quot; l$heights #&gt; [1] 1.66 1.84 1.83 1.56 列表只有 names 属性，没有行列名属性： names(l) #&gt; [1] &quot;sex&quot; &quot;age&quot; &quot;heights&quot; 类似于数据框，[[]] 取子集得到一个列表元素，而 [] 得到一个子列表。 l[&#39;sex&#39;] #&gt; $sex #&gt; [1] &quot;F&quot; &quot;M&quot; l[[&#39;sex&#39;]] #&gt; [1] &quot;F&quot; &quot;M&quot; 列表是支持嵌套的，下面我们将两个列表 l 放到一起： l2 &lt;- l l2$l1 &lt;- l l2 #&gt; $sex #&gt; [1] &quot;F&quot; &quot;M&quot; #&gt; #&gt; $age #&gt; [1] 17 29 20 #&gt; #&gt; $heights #&gt; [1] 1.66 1.84 1.83 1.56 #&gt; #&gt; $l1 #&gt; $l1$sex #&gt; [1] &quot;F&quot; &quot;M&quot; #&gt; #&gt; $l1$age #&gt; [1] 17 29 20 #&gt; #&gt; $l1$heights #&gt; [1] 1.66 1.84 1.83 1.56 2.2 控制结构 在处理数据分析任务时，我们很少能够简单依赖命令的顺序执行就完成任务。为了处理程序的复杂逻辑以及减少代码量，我们需要学习条件与循环控制的使用。 2.2.1 条件控制 2.2.1.1 if 语句 if 语句是最常用的条件结构，它由 if 关键字、条件判断语句和代码块组成： age &lt;- 20 if (age &gt; 18) { # 如果条件判断结果为 TRUE # 该代码块中的语句会执行 message(&quot;你是个成年人啦！&quot;) } #&gt; 你是个成年人啦！ 条件判断语句结果必须返回一个逻辑值，即 TRUE 或 FALSE。如果返回为 TRUE，随后以 {} 包裹的代码块会被执行。如果我们要处理为 FALSE 的情况，增加一个可选的 else 语句块。 age &lt;- 16 if (age &gt; 18) { # 为 TRUE 时执行 message(&quot;你是个成年人啦！&quot;) } else { # 为 FALSE 时执行 message(&quot;你还是个小孩子哟！&quot;) } #&gt; 你还是个小孩子哟！ 代码块中可以包含任意代码，所以 if-else 语句是支持内部嵌套的，结构如下： if () { if () { } else { } } else { } 如果需要处理的情况是多种，if-else 语句可以连用。例如： age &lt;- 17 if (age &gt; 18) { message(&quot;你是个成年人啦！&quot;) } else if (age &lt; 17) { message(&quot;你还是个小孩子哟！&quot;) } else { message(&quot;恭喜你，快要成年了！&quot;) } #&gt; 恭喜你，快要成年了！ 2.2.1.2 switch 语句 swtich 语句在 R 中存在，但读者会极少见到和使用它。结构如下： switch(EXPR, ...) 这里 EXPR 指代表达式，而 ... 说明可以输入命名参数。 这里只举一个简单的例子： ch &lt;- c(&quot;b&quot;) cat(ch,&quot;:&quot;, switch(EXPR = ch, a = 1, b = 2:3), &quot;\\n&quot;) #&gt; b : 2 3 switch 与函数式编程结合更具不凡的威力，其他场景下我极少见到该语句被使用。因此，我建议初学者了解即可，不必掌握。当然，读者如果遇到非常适合的场景也不妨试一试它，应该是可以让代码更为精炼有效的。 2.2.1.3 提示信息 编写程序时，通过输出一些提示信息可以更好地显示程序的运行状态是否如我们所预期，这是一个初学者需要掌握的一个技巧，能有效避免错误和帮助调试错误。 R 可以通过 print()、message()、cat()、warning() 和 stop() 输出提示信息，只有 stop() 会让程序终止。 读者通过下面的输出比较前几者的差别： print(&quot;Running...&quot;) #&gt; [1] &quot;Running...&quot; message(&quot;Running...&quot;) #&gt; Running... cat(&quot;Running...\\n&quot;) #&gt; Running... warning(&quot;Running...&quot;) #&gt; Warning: Running... cat() 与 message() 看起来差别不大，但 cat() 无法被禁止输出，默认没有换行。另外 message() 和 warning() 的信息是可以被抑制掉的，如下： message(&quot;Running...&quot;) #&gt; Running... suppressMessages(message(&quot;Running...&quot;)) warning(&quot;Running...&quot;) #&gt; Warning: Running... suppressWarnings(warning(&quot;Running...&quot;)) 我们再来了解下 stop()，它会直接让程序终止掉，这可以有效避免正确的代码跑错误的数据。 例如，计算均值需要一个数值型数据，但我们却传递了一个字符串： heights_str &lt;- as.character(heights) if (!is.numeric(heights_str)) { stop(&quot;无法对字符串计算！&quot;) } else { # 下面的代码不会被运行 mu &lt;- mean(heights_str) } #&gt; Error in eval(expr, envir, enclos): 无法对字符串计算！ 一般情况下，我推荐读者按需使用 message()/print()、warning() 和 stop() 这几个函数，它们体现信息的 3 个不同级别： message()/print() 提供普通的输出信息。 warning() 提供需要注意的警告信息。 stop() 提供令程序停止运行的信息。 2.2.2 循环控制 当我们需要重复某一个（堆）操作时，就需要用到循环的力量了。R 中的循环语句效率历来被人诟病，但实际上已经大有改进。循环语句相比后面提到的 apply 家族函数具有更高的可读性，且容易理解和调试，因此我个人推荐初学者使用。如果本小节提到的几个循环控制语句确实影响到读者程序的效率，再找其他办法也不迟。 在此强调一下，无论是程序的编写还是科研分析工作，完成永远比高效重要。 2.2.2.1 for 语句 for 语句需要配合迭代变量、in 关键字一起使用，结构如下： for (i in obj) { # 这里输入任意条语句 } 这里 i 指代迭代变量，它可以是索引，也可以是子数据集。obj 指代一个可迭代对象。 针对循环打印变量 heights 的信息，可以有以下 2 种方式： # 第一种方式 # 直接循环迭代对象本身 for (i in heights) { print(i) } #&gt; [1] 1.7 #&gt; [1] 1.72 #&gt; [1] 1.8 #&gt; [1] 1.66 #&gt; [1] 1.65 #&gt; [1] 1.88 # 第二种方式 # 通过索引进行迭代 for (i in 1:length(heights)) { print(heights[i]) } #&gt; Student: 1 #&gt; 1.7 #&gt; Student: 2 #&gt; 1.72 #&gt; Student: 3 #&gt; 1.8 #&gt; Student: 4 #&gt; 1.66 #&gt; Student: 5 #&gt; 1.65 #&gt; Student: 6 #&gt; 1.88 第二种方式写法看起来更为复杂，但如果针对一些复杂的程序，它则显得更加逻辑分明。 初学者容易犯的一个错误是将 in 后面的可迭代对象写成一个标量，如下： for (i in length(heights)) { print(heights[i]) } #&gt; Student: 6 #&gt; 1.88 需要注意下面两者的区别： length(heights) #&gt; [1] 6 1:length(heights) #&gt; [1] 1 2 3 4 5 6 一种更好的写法是使用 seq_along(heights) 替代 1:length(heights)： for (i in seq_along(heights)) { print(heights[i]) } #&gt; Student: 1 #&gt; 1.7 #&gt; Student: 2 #&gt; 1.72 #&gt; Student: 3 #&gt; 1.8 #&gt; Student: 4 #&gt; 1.66 #&gt; Student: 5 #&gt; 1.65 #&gt; Student: 6 #&gt; 1.88 seq_along() 会自动返回可迭代对象的索引序列： seq_along(heights) #&gt; [1] 1 2 3 4 5 6 2.2.2.2 while 语句 for 语句已经能满足一般场景的使用，while 语句则特别适合于算法的设计中： 不知道要运行多少次循环。 知道要退出循环的条件。 下面举一个简单的例子： v &lt;- 10 while(v &gt; 2) { print(v) v &lt;- v - 1.1 } #&gt; [1] 10 #&gt; [1] 8.9 #&gt; [1] 7.8 #&gt; [1] 6.7 #&gt; [1] 5.6 #&gt; [1] 4.5 #&gt; [1] 3.4 #&gt; [1] 2.3 2.2.2.3 repeat 语句与循环退出 repeat 语句我从来没有使用过，它类似与 C 语言中的 do-while 语句，即先运行一段程序，然后看一看是否需要退出去。 它的结构如下： repeat EXPR EXPR 指代一个语句块。为了退出 repeat 循环，我们需要借助 break 语句的力量。 下面是一个简单例子： i &lt;- 1 repeat{ print(i) i &lt;- i*2 if (i &gt; 100) break } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 4 #&gt; [1] 8 #&gt; [1] 16 #&gt; [1] 32 #&gt; [1] 64 break 语句执行后将跳出当前的循环，另有 next 语句，它可以跳过后续代码的运行进入下一次循环。 基于上面的例子我们再构造一个示例： i &lt;- 1 repeat{ print(i) i &lt;- i*2 if (i &gt; 200) break() if (i &gt; 100) next() print(&quot;Can you see me?&quot;) } #&gt; [1] 1 #&gt; [1] &quot;Can you see me?&quot; #&gt; [1] 2 #&gt; [1] &quot;Can you see me?&quot; #&gt; [1] 4 #&gt; [1] &quot;Can you see me?&quot; #&gt; [1] 8 #&gt; [1] &quot;Can you see me?&quot; #&gt; [1] 16 #&gt; [1] &quot;Can you see me?&quot; #&gt; [1] 32 #&gt; [1] &quot;Can you see me?&quot; #&gt; [1] 64 #&gt; [1] 128 当 i &gt; 100 后，最后一条输出语句就不再运行。 2.3 函数与函数式编程 2.4 包的安装与使用 2.4.1 标准安装 2.4.2 Pacman 2.4.3 包使用 R 启动时默认加载的包可以通过 .packages() 命令获取： print(.packages()) #&gt; [1] &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; #&gt; [5] &quot;datasets&quot; &quot;pacman&quot; &quot;methods&quot; &quot;base&quot; 由于在第 1 章的配置一节中我有介绍使用 pacman 包作为第三方的包管理器，在 ~/.Rprofile 中进行了设置，所以该包随着 R 的启动也被加载了。 整个 R 会话当前的所有信息都可以通过 sessionInfo() 获取，在向他人提问时提交该命令结果是一个良好的习惯。 sessionInfo() #&gt; R version 3.6.3 (2020-02-29) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 18362) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=Chinese (Simplified)_China.936 #&gt; [2] LC_CTYPE=Chinese (Simplified)_China.936 #&gt; [3] LC_MONETARY=Chinese (Simplified)_China.936 #&gt; [4] LC_NUMERIC=C #&gt; [5] LC_TIME=Chinese (Simplified)_China.936 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets #&gt; [6] methods base #&gt; #&gt; other attached packages: #&gt; [1] pacman_0.5.1 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] Rcpp_1.0.4 pillar_1.4.3 #&gt; [3] compiler_3.6.3 highr_0.8 #&gt; [5] prettyunits_1.1.1 tools_3.6.3 #&gt; [7] digest_0.6.25 pkgbuild_1.0.6 #&gt; [9] tibble_2.1.3 evaluate_0.14 #&gt; [11] lifecycle_0.2.0 gtable_0.3.0 #&gt; [13] pkgconfig_2.0.3 rlang_0.4.5 #&gt; [15] cli_2.0.2 rstudioapi_0.11 #&gt; [17] parallel_3.6.3 yaml_2.2.1 #&gt; [19] xfun_0.12 loo_2.2.0 #&gt; [21] gridExtra_2.3 dplyr_0.8.5 #&gt; [23] stringr_1.4.0 knitr_1.28 #&gt; [25] tidyselect_1.0.0 stats4_3.6.3 #&gt; [27] grid_3.6.3 inline_0.3.15 #&gt; [29] glue_1.3.2 R6_2.4.1 #&gt; [31] processx_3.4.2 fansi_0.4.1 #&gt; [33] rmarkdown_2.1 bookdown_0.18 #&gt; [35] rstan_2.19.3 purrr_0.3.3 #&gt; [37] callr_3.4.2 ggplot2_3.3.0 #&gt; [39] magrittr_1.5 matrixStats_0.56.0 #&gt; [41] scales_1.1.0 ps_1.3.2 #&gt; [43] htmltools_0.4.0 StanHeaders_2.21.0-1 #&gt; [45] assertthat_0.2.1 colorspace_1.4-1 #&gt; [47] stringi_1.4.6 munsell_0.5.0 #&gt; [49] crayon_1.3.4 2.5 实战：ROC 曲线计算与绘制 本节我们通过一个计算实例来整合上述所有的知识点。 2.6 常见问题与方案 除了本节目前罗列的问题，读者在学习本章内容时遇到的其他问题都可以通过 GitHub Issue 提出和进行讨论。如果读者提出的是通性问题，将增补到该节。 2.6.1 = 与 &lt;- 的区别 2.6.2 因子重构 如果我们向变量 sex 扩充两个 M，可能会遇到不能理解的结果： sex &lt;- factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;)) sex &lt;- c(sex, c(&quot;M&quot;, &quot;M&quot;)) sex #&gt; [1] &quot;2&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;M&quot; &quot;M&quot; 根本原因在于，当我们创建因子后，因子本身存储的实际内容已经被替换为了正整数，分类信息被存储到了水平中，正整数与分类产生的映射对依旧可以保存原本的信息。 sex &lt;- factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;)) str(sex) #&gt; Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 这样做的好处是节省内存开销，并有利于模型计算： 当存在大量字符串时，R 依然只有少量的正整数即可表示。 数学模型并不支持字符串，当将因子纳入统计模型中时，实际上参与计算的是对应的正整数。 解决上述问题的一个办法是先将 sex 转换回字符串，然后再创建因子。 sex &lt;- factor(c(as.character(sex), &quot;M&quot;, &quot;M&quot;)) sex #&gt; [1] Male Female Female Male Male M M #&gt; Levels: Female M Male "],
["import.html", "第 3 章 数据导入 CSV Excel 常见问题与方案", " 第 3 章 数据导入 瞎扯几句。 CSV Excel 常见问题与方案 除了本节目前罗列的问题，读者在学习本章内容时遇到的其他问题都可以通过 GitHub Issue 提出和进行讨论。如果读者提出的是通性问题，将增补到该节。 "],
["clean.html", "第 4 章 数据清洗 常见问题与方案", " 第 4 章 数据清洗 瞎扯几句。 常见问题与方案 除了本节目前罗列的问题，读者在学习本章内容时遇到的其他问题都可以通过 GitHub Issue 提出和进行讨论。如果读者提出的是通性问题，将增补到该节。 "],
["visualization.html", "第 5 章 数据可视化 常见问题与方案", " 第 5 章 数据可视化 瞎扯几句。 常见问题与方案 除了本节目前罗列的问题，读者在学习本章内容时遇到的其他问题都可以通过 GitHub Issue 提出和进行讨论。如果读者提出的是通性问题，将增补到该节。 "],
["model.html", "第 6 章 统计建模 常见问题与方案", " 第 6 章 统计建模 瞎扯几句。 常见问题与方案 除了本节目前罗列的问题，读者在学习本章内容时遇到的其他问题都可以通过 GitHub Issue 提出和进行讨论。如果读者提出的是通性问题，将增补到该节。 "],
["report.html", "第 7 章 结果展示 图形 表格 RMarkdown Shiny 常见问题与方案", " 第 7 章 结果展示 瞎扯几句。 图形 表格 RMarkdown Shiny 常见问题与方案 除了本节目前罗列的问题，读者在学习本章内容时遇到的其他问题都可以通过 GitHub Issue 提出和进行讨论。如果读者提出的是通性问题，将增补到该节。 "],
["bioapp.html", "第 8 章 生物信息学应用", " 第 8 章 生物信息学应用 瞎扯几句。 "],
["expand-reading.html", "A 拓展阅读 A.1 生信技能树语雀知识库 A.2 图书 A.3 视频 A.4 公众号 A.5 其他资料", " A 拓展阅读 呐，到这里本教程的内容差不多写完了。下面是一些推荐的学习资料，希望能够帮到想要进一步学习的读者。 大部分的资料是英文的，大家一定要根据自己的实际情况选择合适的资料，建立切实可行的学习计划。 A.1 生信技能树语雀知识库 生物信息入门需要了解的十个专题 生物统计从理论到实践 肿瘤外显子数据分析指南 TCGA数据分析指南 生信菜鸟团-每周文献分享 A.2 图书 A.2.1 问题与方案 Cookbook for R 中文版 A.2.2 统计建模 Data Science Live Book Statistical Inference via Data Science - A ModernDive into R and the tidyverse A.2.3 核心集合 R for Data Science Anvanced R R Packages A.2.4 生物信息学 生物信息学生 R 入门教程 A.2.5 R R 语言教程 A.3 视频 生信技能树 B 站视频集 A.4 公众号 生信菜鸟团 生信技能树 biobabble 优雅R A.5 其他资料 Jimmy - GEO 流程 Jimmy - NGS 流程 "],
["references.html", "参考文献", " 参考文献 "]
]
